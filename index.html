<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Truth MUD - The Canonical Library</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0a0e27 0%, #1a0527 100%);
            color: #e0e0ff;
            font-family: 'Georgia', serif;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Setup Screen */
        .setup-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        .setup-container {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #4a5fff;
            border-radius: 15px;
            padding: 40px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 0 50px rgba(74, 95, 255, 0.3);
            animation: fadeIn 1s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .mirror-text {
            background: linear-gradient(90deg, #fff, #aaf, #fff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 3s infinite;
            font-size: 2.5em;
            text-align: center;
            margin-bottom: 20px;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0%; }
            50% { background-position: 100%; }
        }

        .api-input {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #4a5fff;
            color: #e0e0ff;
            border-radius: 5px;
            font-size: 1em;
            font-family: monospace;
        }

        .api-input:focus {
            outline: none;
            box-shadow: 0 0 15px rgba(74, 95, 255, 0.5);
        }

        .setup-button {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: linear-gradient(135deg, #4a5fff, #6a7fff);
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
            transition: all 0.3s;
        }

        .setup-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(74, 95, 255, 0.5);
        }

        .setup-button.secondary {
            background: rgba(74, 95, 255, 0.2);
            border: 1px solid #4a5fff;
        }

        /* Status Indicator */
        .status-panel {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid #4a5fff;
            border-radius: 10px;
            padding: 15px;
            z-index: 1000;
            display: none;
        }

        .status-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 10px;
            animation: pulse 2s infinite;
        }

        .status-dot.active {
            background: #4ade80;
        }

        .status-dot.inactive {
            background: #f87171;
        }

        .status-dot.processing {
            background: #fbbf24;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Main Game Container */
        #game-container {
            display: none;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Covenant Screen */
        .covenant-screen {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #4a5fff;
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 0 30px rgba(74, 95, 255, 0.3);
        }

        /* Creation Screen */
        .creation-screen {
            display: none;
            animation: fadeIn 1s ease-in;
        }

        .scene-container {
            background: rgba(10, 10, 30, 0.9);
            border: 1px solid #4a5fff;
            border-radius: 10px;
            padding: 30px;
            margin: 20px 0;
            min-height: 200px;
        }

        .scene-text {
            font-size: 1.1em;
            line-height: 1.8;
            margin-bottom: 20px;
            white-space: pre-wrap;
        }

        .choice-btn {
            background: linear-gradient(135deg, #1a1a3a, #2a2a4a);
            border: 1px solid #4a5fff;
            color: #e0e0ff;
            padding: 15px 30px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1.1em;
            margin: 10px;
        }

        .choice-btn:hover {
            background: linear-gradient(135deg, #2a2a4a, #3a3a5a);
            box-shadow: 0 0 15px rgba(74, 95, 255, 0.5);
            transform: translateY(-2px);
        }

        /* Game Screen */
        .game-screen {
            display: none;
            animation: fadeIn 1s ease-in;
        }

        #image-display {
            width: 100%;
            height: 500px;
            background: #000;
            border: 2px solid #4a5fff;
            border-radius: 10px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        .room-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .image-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #4a5fff;
            font-size: 1.2em;
            display: none;
        }

        .quantum-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle at var(--mouse-x, 50%) var(--mouse-y, 50%), 
                rgba(100, 200, 255, 0.1) 0%, 
                transparent 50%);
            mix-blend-mode: screen;
        }

        #text-output {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #4a5fff;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            height: 300px;
            overflow-y: auto;
            font-size: 1.05em;
            line-height: 1.6;
        }

        .room-name {
            color: #64c8ff;
            font-weight: bold;
            font-size: 1.2em;
            margin-bottom: 5px;
        }

        .librarian-voice {
            border-left: 3px solid #8b5cf6;
            padding-left: 15px;
            margin: 10px 0;
            font-style: italic;
            color: #c4b5fd;
        }

        .system-message {
            color: #888;
            font-size: 0.9em;
            font-style: italic;
        }

        #command-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #4a5fff;
            color: #e0e0ff;
            padding: 15px;
            border-radius: 5px;
            font-size: 1.1em;
            font-family: 'Georgia', serif;
        }

        #command-input:focus {
            outline: none;
            box-shadow: 0 0 15px rgba(74, 95, 255, 0.5);
        }

        #command-input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Character Display */
        .character-display {
            position: fixed;
            top: 70px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #4a5fff;
            padding: 15px;
            border-radius: 5px;
            width: 200px;
        }

        .stat-bar {
            height: 4px;
            background: rgba(74, 95, 255, 0.3);
            border-radius: 2px;
            margin: 5px 0;
            overflow: hidden;
        }

        .stat-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a5fff, #64c8ff);
            transition: width 0.5s ease;
        }

        /* Map Display */
        .map-display {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #4a5fff;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }

        .map-room {
            display: inline-block;
            width: 30px;
            height: 30px;
            margin: 2px;
            background: rgba(74, 95, 255, 0.2);
            border: 1px solid #4a5fff;
            cursor: pointer;
            position: relative;
        }

        .map-room.current {
            background: #4a5fff;
            animation: pulse 2s infinite;
        }

        .map-room.visited {
            background: rgba(74, 95, 255, 0.5);
        }

        /* Loading Spinner */
        .quantum-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(100, 200, 255, 0.3);
            border-top: 3px solid #64c8ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Image Cache Display */
        .cache-info {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #4a5fff;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.8em;
            font-family: monospace;
        }

        /* Error Message */
        .error-message {
            background: rgba(248, 113, 113, 0.1);
            border: 1px solid #f87171;
            color: #fca5a5;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        /* Success Message */
        .success-message {
            background: rgba(74, 222, 128, 0.1);
            border: 1px solid #4ade80;
            color: #86efac;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <!-- Setup Screen -->
    <div id="setup-screen" class="setup-screen">
        <div class="setup-container">
            <h1 class="mirror-text">The Canonical Library</h1>
            <p style="text-align: center; margin: 20px 0; line-height: 1.6;">
                A Quantum Truth MUD powered by AI
            </p>
            
            <div style="margin: 30px 0;">
                <label style="display: block; margin-bottom: 10px;">OpenAI API Key:</label>
                <input type="password" id="api-key-input" class="api-input" placeholder="sk-..." value="">
                <p style="font-size: 0.9em; color: #888; margin-top: 5px;">
                    Your API key is stored locally and never sent to any server except OpenAI.
                </p>
            </div>
            
            <button class="setup-button" onclick="game.validateAndStart()">
                Enter the Library
            </button>
            
            <button class="setup-button secondary" onclick="game.startOffline()">
                Play Offline (No AI/Images)
            </button>
            
            <p style="text-align: center; margin-top: 20px; font-size: 0.9em; color: #888;">
                Get your API key from <a href="https://platform.openai.com/api-keys" target="_blank" style="color: #4a5fff;">OpenAI Platform</a>
            </p>
        </div>
    </div>

    <!-- Status Panel -->
    <div id="status-panel" class="status-panel">
        <div class="status-item">
            <div class="status-dot inactive" id="ai-status"></div>
            <span>AI: <span id="ai-status-text">Offline</span></span>
        </div>
        <div class="status-item">
            <div class="status-dot inactive" id="image-status"></div>
            <span>Images: <span id="image-status-text">Offline</span></span>
        </div>
        <div class="status-item">
            <span style="font-size: 0.9em;">Tokens: <span id="token-count">0</span></span>
        </div>
    </div>

    <!-- Main Game Container -->
    <div id="game-container">
        <!-- Covenant Screen -->
        <div id="covenant" class="covenant-screen">
            <h1 class="mirror-text">The Mirror Covenant</h1>
            <h2>⚠️ Essential Understanding</h2>
            
            <ul style="margin: 20px 0; line-height: 1.8;">
                <li>Your character reflects your true nature through your choices</li>
                <li>The Quantum Librarian AI observes and responds to your authentic self</li>
                <li>Each room is uniquely generated based on your quantum state</li>
                <li>Your journey is yours alone - no two paths are the same</li>
            </ul>
            
            <p style="margin: 20px 0; font-style: italic; text-align: center;">
                "We don't see things as they are, we see them as we are." - Anaïs Nin
            </p>
            
            <div style="text-align: center;">
                <button class="choice-btn" onclick="game.acceptCovenant()">
                    I Accept the Mirror's Truth
                </button>
            </div>
        </div>

        <!-- Character Creation -->
        <div id="creation" class="creation-screen">
            <div class="scene-container">
                <div id="creation-text" class="scene-text"></div>
                <div id="creation-choices" class="choices"></div>
            </div>
        </div>

        <!-- Main Game -->
        <div id="game" class="game-screen">
            <div id="image-display">
                <img id="room-image" class="room-image" src="" alt="">
                <div class="image-loading" id="image-loading">
                    <div class="quantum-spinner"></div>
                    <p>Generating quantum reality...</p>
                </div>
                <div class="quantum-overlay"></div>
            </div>
            <div id="text-output"></div>
            <input type="text" id="command-input" placeholder="What do you do?" onkeypress="if(event.key==='Enter') game.processCommand()">
        </div>

        <!-- Character Display -->
        <div id="character" class="character-display" style="display: none;">
            <div style="text-align: center; font-weight: bold; color: #64c8ff; margin-bottom: 10px;">
                <span id="char-name">Unknown</span>
            </div>
            <div style="font-size: 0.9em;">
                <div>Truth: <span id="truth-density">50%</span></div>
                <div class="stat-bar"><div class="stat-fill" id="truth-bar" style="width: 50%"></div></div>
                
                <div>Quantum: <span id="quantum-coherence">0%</span></div>
                <div class="stat-bar"><div class="stat-fill" id="quantum-bar" style="width: 0%"></div></div>
                
                <div>Shadow: <span id="shadow-integration">0%</span></div>
                <div class="stat-bar"><div class="stat-fill" id="shadow-bar" style="width: 0%"></div></div>
                
                <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #4a5fff;">
                    <div>Stage: <span id="hero-stage" style="color: #aaf;">Threshold</span></div>
                    <div>Actions: <span id="action-count" style="color: #aaf;">0</span></div>
                </div>
            </div>
        </div>

        <!-- Map Display -->
        <div id="map" class="map-display">
            <div style="color: #888; font-size: 0.8em; margin-bottom: 5px;">Known Paths:</div>
            <div id="map-grid"></div>
        </div>

        <!-- Cache Info -->
        <div class="cache-info">
            <div>Images Cached: <span id="cache-count">0</span></div>
            <div>Cache Size: <span id="cache-size">0 KB</span></div>
        </div>
    </div>

    <script>
        class QuantumTruthMUD {
            constructor() {
                this.apiKey = null;
                this.aiEnabled = false;
                this.imageCache = new Map();
                this.tokenCount = 0;
                this.processingCommand = false;
                
                this.state = {
                    stage: 'setup',
                    player: null,
                    currentRoom: null,
                    visitedRooms: new Set(),
                    actionCount: 0,
                    history: [],
                    quantumState: {
                        coherence: 0,
                        entanglement: [],
                        superposition: 0
                    },
                    truthDensity: 0.5,
                    shadowIntegration: 0,
                    creationData: {
                        observations: [],
                        currentScene: 0,
                        startTime: Date.now()
                    }
                };

                // Room templates (AI will enhance these)
                this.roomTemplates = {
                    'entrance': {
                        name: 'The Library Entrance',
                        basePrompt: 'A vast library entrance with quantum properties, doors that exist in superposition',
                        exits: { north: 'hall_of_mirrors', east: 'garden_of_forking_paths', west: 'shadow_archive' },
                        literary: 'borges'
                    },
                    'hall_of_mirrors': {
                        name: 'The Hall of Mirrors',
                        basePrompt: 'An infinite hall of mirrors showing different versions of reality, Alice in Wonderland style',
                        exits: { south: 'entrance', north: 'quantum_laboratory', east: 'tea_room' },
                        literary: 'carroll'
                    },
                    'garden_of_forking_paths': {
                        name: 'The Garden of Forking Paths',
                        basePrompt: 'A garden where every path branches into infinite possibilities, Borges-inspired labyrinth',
                        exits: { west: 'entrance', north: 'tea_room', east: 'oracle_chamber' },
                        literary: 'borges'
                    },
                    'shadow_archive': {
                        name: 'The Shadow Archive',
                        basePrompt: 'A dark library containing shadow selves and repressed memories, Jungian psychology',
                        exits: { east: 'entrance', north: 'abyss_reading_room' },
                        literary: 'jung'
                    },
                    'tea_room': {
                        name: 'The Mad Tea Room',
                        basePrompt: 'A perpetual tea party frozen in time, Mad Hatter\'s tea party from Alice in Wonderland',
                        exits: { south: 'garden_of_forking_paths', west: 'hall_of_mirrors' },
                        literary: 'carroll'
                    },
                    'quantum_laboratory': {
                        name: 'The Quantum Laboratory',
                        basePrompt: 'A laboratory where Schrödinger\'s cat exists in superposition, quantum physics made visible',
                        exits: { south: 'hall_of_mirrors', east: 'oracle_chamber' },
                        literary: 'science'
                    },
                    'oracle_chamber': {
                        name: 'The Oracle Chamber',
                        basePrompt: 'Ancient temple meets quantum uncertainty, Oracle speaks in superpositions, Eastern philosophy',
                        exits: { west: 'garden_of_forking_paths', north: 'quantum_laboratory' },
                        literary: 'eastern'
                    },
                    'abyss_reading_room': {
                        name: 'The Abyss Reading Room',
                        basePrompt: 'A void library where unwritten books exist, Nietzschean abyss that gazes back',
                        exits: { south: 'shadow_archive' },
                        literary: 'philosophy'
                    }
                };

                // Character creation scenes
                this.creationScenes = [
                    {
                        text: 'The threshold observes you before you observe it.\n\nHow do you approach the unknown?',
                        choices: [
                            { text: 'Rush forward into mystery', value: 'active' },
                            { text: 'Study the patterns first', value: 'contemplative' },
                            { text: 'Feel for the right moment', value: 'intuitive' },
                            { text: 'Test each step carefully', value: 'cautious' }
                        ]
                    },
                    {
                        text: 'Three paths appear, but you sense they\'re choosing you:\n\n- Stairs descending into your fears\n- Light bridge over infinite void\n- Familiar hall that shouldn\'t exist\n\nWhich accepts you?',
                        choices: [
                            { text: 'The descent into shadow', value: 'shadow-seeker' },
                            { text: 'The bridge of faith', value: 'faith-walker' },
                            { text: 'The impossible familiar', value: 'comfort-drawn' },
                            { text: 'Wait for them to choose', value: 'observer' }
                        ]
                    },
                    {
                        text: 'Mirrors show not reflections but possibilities:\n\n- A hero you\'ll never be\n- A child you\'ve forgotten\n- A shadow wearing your face\n- An elder remembering your future\n\nWhich is most true?',
                        choices: [
                            { text: 'The impossible hero', value: 'idealized' },
                            { text: 'The forgotten child', value: 'vulnerable' },
                            { text: 'The familiar shadow', value: 'integrated' },
                            { text: 'The future memory', value: 'wisdom' }
                        ]
                    },
                    {
                        text: 'A book burns with your forgotten moments.\nThe fire reveals rather than destroys.\n\nWhat do you do with your hidden self?',
                        choices: [
                            { text: 'Read every burning word', value: 'full-integration' },
                            { text: 'Let the fire cleanse', value: 'rejection' },
                            { text: 'Save one essential page', value: 'partial-integration' },
                            { text: 'Add new pages to burn', value: 'shadow-work' }
                        ]
                    },
                    {
                        text: 'The Library asks for your true name.\nNot given, not chosen, but the one that resonates in quantum space.',
                        choices: [
                            { text: 'Speak it into being', value: 'named', input: true },
                            { text: 'Remain undefined', value: 'unnamed' }
                        ]
                    }
                ];

                this.initializeGame();
            }

            initializeGame() {
                // Load saved API key
                const savedKey = localStorage.getItem('qmud_api_key');
                if (savedKey) {
                    document.getElementById('api-key-input').value = savedKey;
                }

                // Load saved state
                this.loadState();

                // Mouse tracking for quantum overlay
                document.addEventListener('mousemove', (e) => {
                    const display = document.getElementById('image-display');
                    if (display) {
                        const rect = display.getBoundingClientRect();
                        const x = ((e.clientX - rect.left) / rect.width * 100) + '%';
                        const y = ((e.clientY - rect.top) / rect.height * 100) + '%';
                        display.style.setProperty('--mouse-x', x);
                        display.style.setProperty('--mouse-y', y);
                    }
                });

                // Auto-save
                setInterval(() => this.saveState(), 30000);
            }

            async validateAndStart() {
                const apiKey = document.getElementById('api-key-input').value.trim();
                
                if (!apiKey || !apiKey.startsWith('sk-')) {
                    alert('Please enter a valid OpenAI API key');
                    return;
                }

                // Test the API key
                try {
                    const response = await fetch('https://api.openai.com/v1/models', {
                        headers: {
                            'Authorization': `Bearer ${apiKey}`
                        }
                    });

                    if (!response.ok) {
                        throw new Error('Invalid API key');
                    }

                    // Save and continue
                    this.apiKey = apiKey;
                    localStorage.setItem('qmud_api_key', apiKey);
                    this.aiEnabled = true;
                    
                    document.getElementById('setup-screen').style.display = 'none';
                    document.getElementById('game-container').style.display = 'block';
                    document.getElementById('status-panel').style.display = 'block';
                    
                    this.updateStatus('ai', 'active', 'Connected');
                    this.updateStatus('image', 'active', 'Ready');
                    
                    this.state.stage = 'covenant';

                } catch (error) {
                    alert('Invalid API key. Please check and try again.');
                }
            }

            startOffline() {
                this.aiEnabled = false;
                document.getElementById('setup-screen').style.display = 'none';
                document.getElementById('game-container').style.display = 'block';
                document.getElementById('status-panel').style.display = 'block';
                
                this.updateStatus('ai', 'inactive', 'Offline');
                this.updateStatus('image', 'inactive', 'Offline');
                
                this.state.stage = 'covenant';
            }

            updateStatus(type, status, text) {
                document.getElementById(`${type}-status`).className = `status-dot ${status}`;
                document.getElementById(`${type}-status-text`).textContent = text;
            }

            acceptCovenant() {
                document.getElementById('covenant').style.display = 'none';
                document.getElementById('creation').style.display = 'block';
                this.state.stage = 'creation';
                this.startCharacterCreation();
            }

            startCharacterCreation() {
                this.showCreationScene(0);
            }

            showCreationScene(index) {
                if (index >= this.creationScenes.length) {
                    this.finalizeCharacter();
                    return;
                }

                const scene = this.creationScenes[index];
                const textEl = document.getElementById('creation-text');
                const choicesEl = document.getElementById('creation-choices');

                textEl.textContent = scene.text;
                choicesEl.innerHTML = '';

                if (scene.choices[0].input) {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'api-input';
                    input.placeholder = 'Your true name...';
                    input.style.marginBottom = '10px';
                    choicesEl.appendChild(input);

                    scene.choices.forEach(choice => {
                        const btn = document.createElement('button');
                        btn.className = 'choice-btn';
                        btn.textContent = choice.text;
                        btn.onclick = () => {
                            const value = choice.value === 'named' ? input.value || 'Unnamed' : '[SILENCE]';
                            this.recordCreationChoice(index, choice.value, value);
                            this.showCreationScene(index + 1);
                        };
                        choicesEl.appendChild(btn);
                    });
                } else {
                    scene.choices.forEach(choice => {
                        const btn = document.createElement('button');
                        btn.className = 'choice-btn';
                        btn.textContent = choice.text;
                        btn.onclick = () => {
                            this.recordCreationChoice(index, choice.value);
                            this.showCreationScene(index + 1);
                        };
                        choicesEl.appendChild(btn);
                    });
                }
            }

            recordCreationChoice(sceneIndex, value, extra = null) {
                this.state.creationData.observations.push({
                    scene: sceneIndex,
                    choice: value,
                    extra: extra,
                    timestamp: Date.now() - this.state.creationData.startTime
                });
            }

            async finalizeCharacter() {
                const obs = this.state.creationData.observations;
                
                const trueForm = {
                    name: obs[4]?.extra || 'Seeker',
                    archetype: this.deriveArchetype(obs),
                    shadowLevel: this.deriveShadowLevel(obs),
                    quantumSignature: Math.random(),
                    truthDensity: 0.5,
                    heroStage: 'Threshold'
                };

                this.state.player = trueForm;
                this.state.currentRoom = 'entrance';
                
                // Adjust initial stats based on choices
                if (obs[0]?.choice === 'contemplative') this.state.quantumState.coherence += 0.1;
                if (obs[1]?.choice === 'shadow-seeker') this.state.shadowIntegration += 0.2;
                if (obs[2]?.choice === 'integrated') this.state.shadowIntegration += 0.3;
                if (obs[3]?.choice === 'full-integration') this.state.shadowIntegration += 0.4;

                // If AI enabled, get personalized introduction
                if (this.aiEnabled) {
                    await this.getAIIntroduction();
                }

                this.startGame();
            }

            deriveArchetype(observations) {
                const archetypes = {
                    'active': 'Warrior',
                    'contemplative': 'Sage',
                    'intuitive': 'Mystic',
                    'cautious': 'Guardian'
                };
                return archetypes[observations[0]?.choice] || 'Wanderer';
            }

            deriveShadowLevel(observations) {
                let shadow = 0;
                if (observations[2]?.choice === 'integrated') shadow += 0.3;
                if (observations[3]?.choice === 'full-integration') shadow -= 0.2;
                if (observations[3]?.choice === 'rejection') shadow += 0.4;
                return Math.max(0, Math.min(1, shadow + 0.5));
            }

            async getAIIntroduction() {
                const context = this.buildContext();
                const prompt = `As the Quantum Librarian, welcome ${this.state.player.name} (${this.state.player.archetype}) to the Library. 
                    Their truth density is ${this.state.truthDensity}, quantum coherence ${this.state.quantumState.coherence}, 
                    shadow integration ${this.state.shadowIntegration}. 
                    Give a personalized, mysterious welcome that hints at their journey ahead. 
                    Keep it under 100 words and deeply atmospheric.`;

                try {
                    const response = await this.callGPT(prompt, 'system');
                    if (response) {
                        this.librarianMessage = response;
                    }
                } catch (error) {
                    console.error('AI introduction failed:', error);
                }
            }

            startGame() {
                document.getElementById('creation').style.display = 'none';
                document.getElementById('game').style.display = 'block';
                document.getElementById('character').style.display = 'block';
                document.getElementById('map').style.display = 'block';
                
                this.state.stage = 'playing';
                this.updateDisplay();
                this.enterRoom('entrance');
                
                if (this.librarianMessage) {
                    this.addOutput('[The Quantum Librarian speaks:]', 'system-message');
                    this.addOutput(this.librarianMessage, 'librarian-voice');
                } else {
                    this.addOutput(`Welcome to the Canonical Library, ${this.state.player.name}.`);
                    this.addOutput(`You are a ${this.state.player.archetype} at the ${this.state.player.heroStage} of your journey.`);
                }
            }

            async enterRoom(roomId) {
                const room = this.roomTemplates[roomId];
                if (!room) return;

                this.state.currentRoom = roomId;
                this.state.visitedRooms.add(roomId);
                
                this.addOutput(`\n[${room.name}]`, 'room-name');
                
                // Generate or retrieve room image
                if (this.aiEnabled) {
                    await this.generateRoomImage(roomId);
                    await this.generateRoomDescription(roomId);
                } else {
                    this.addOutput(this.getOfflineRoomDescription(roomId));
                }
                
                const exits = Object.keys(room.exits);
                if (exits.length > 0) {
                    this.addOutput(`\nPaths: ${exits.join(', ')}`);
                }

                this.applyQuantumEffects(room);
                this.updateDisplay();
                this.updateMap();
                this.saveState();
            }

            async generateRoomImage(roomId) {
                // Check cache first
                const cacheKey = `${roomId}_${Math.floor(this.state.truthDensity * 10)}_${Math.floor(this.state.quantumState.coherence * 10)}`;
                
                if (this.imageCache.has(cacheKey)) {
                    const cached = this.imageCache.get(cacheKey);
                    document.getElementById('room-image').src = cached;
                    return;
                }

                // Show loading
                document.getElementById('image-loading').style.display = 'block';
                this.updateStatus('image', 'processing', 'Generating...');

                const room = this.roomTemplates[roomId];
                const imagePrompt = `${room.basePrompt}, 
                    truth density ${this.state.truthDensity > 0.7 ? 'high luminous' : this.state.truthDensity < 0.3 ? 'dark shadowy' : 'twilight uncertain'}, 
                    quantum coherence ${this.state.quantumState.coherence > 0.5 ? 'stable reality' : 'reality fragmenting'}, 
                    shadow level ${this.state.shadowIntegration > 0.5 ? 'shadows visible and active' : 'shadows lurking hidden'},
                    literary style: ${room.literary}, 
                    photorealistic, cinematic lighting, mysterious atmosphere`;

                try {
                    const response = await fetch('https://api.openai.com/v1/images/generations', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: 'dall-e-3',
                            prompt: imagePrompt,
                            n: 1,
                            size: '1792x1024',
                            quality: 'standard'
                        })
                    });

                    const data = await response.json();
                    
                    if (data.data && data.data[0]) {
                        const imageUrl = data.data[0].url;
                        
                        // Cache the image
                        this.imageCache.set(cacheKey, imageUrl);
                        this.updateCacheDisplay();
                        
                        // Display the image
                        document.getElementById('room-image').src = imageUrl;
                    }
                } catch (error) {
                    console.error('Image generation failed:', error);
                    this.addOutput('[Image generation failed - quantum interference]', 'system-message');
                } finally {
                    document.getElementById('image-loading').style.display = 'none';
                    this.updateStatus('image', 'active', 'Ready');
                }
            }

            async generateRoomDescription(roomId) {
                const room = this.roomTemplates[roomId];
                const context = this.buildContext();
                
                const prompt = `As the Quantum Librarian, describe ${room.name} for ${this.state.player.name}.
                    Literary style: ${room.literary}
                    Player state: Truth ${this.state.truthDensity}, Quantum ${this.state.quantumState.coherence}, Shadow ${this.state.shadowIntegration}
                    Make it personal to their journey. Mention how the room reflects their inner state.
                    Keep it atmospheric and under 150 words.`;

                try {
                    const description = await this.callGPT(prompt, 'system');
                    if (description) {
                        this.addOutput(description);
                    }
                } catch (error) {
                    console.error('Description generation failed:', error);
                    this.addOutput(this.getOfflineRoomDescription(roomId));
                }
            }

            getOfflineRoomDescription(roomId) {
                const descriptions = {
                    'entrance': 'The Library entrance thrums with potential. Doors exist and don\'t exist simultaneously.',
                    'hall_of_mirrors': 'Infinite reflections cascade through impossible geometries. Each shows a different you.',
                    'garden_of_forking_paths': 'Every step creates new timelines. You see yourself walking paths not taken.',
                    'shadow_archive': 'Your shadow moves independently here, browsing shelves of fears and forgotten dreams.',
                    'tea_room': 'Time stopped at 6 o\'clock. Empty chairs wait for aspects of yourself.',
                    'quantum_laboratory': 'Reality equations float mid-air. A cat prowls between existence and void.',
                    'oracle_chamber': 'Ancient wisdom merges with quantum uncertainty. All answers are true until observed.',
                    'abyss_reading_room': 'Books of unwritten stories line the walls. The void reads you as you read it.'
                };
                return descriptions[roomId] || 'The room defies description.';
            }

            async processCommand() {
                const input = document.getElementById('command-input');
                const command = input.value.trim();
                
                if (!command || this.processingCommand) return;
                
                this.processingCommand = true;
                input.disabled = true;
                
                this.addOutput(`> ${command}`, 'command-echo');
                this.state.history.push(command);
                input.value = '';
                
                this.state.actionCount++;
                
                // Process with AI if enabled
                if (this.aiEnabled) {
                    await this.processWithAI(command);
                } else {
                    this.processOffline(command);
                }
                
                this.evolveQuantumState(command);
                this.updateDisplay();
                
                this.processingCommand = false;
                input.disabled = false;
                input.focus();
            }

            async processWithAI(command) {
                this.updateStatus('ai', 'processing', 'Thinking...');
                
                const context = this.buildContext();
                const room = this.roomTemplates[this.state.currentRoom];
                
                const prompt = `As the Quantum Librarian in ${room.name}, respond to player "${command}".
                    Player: ${this.state.player.name} (${this.state.player.archetype})
                    Truth: ${this.state.truthDensity}, Quantum: ${this.state.quantumState.coherence}, Shadow: ${this.state.shadowIntegration}
                    Available exits: ${Object.keys(room.exits).join(', ')}
                    
                    Instructions:
                    - If they're moving (go/walk/move + direction), confirm the movement and describe the transition
                    - React to their truth density and quantum state
                    - Be mysterious and literary
                    - Sometimes change their stats slightly based on their actions
                    - If their action reveals character, note it
                    - Keep response under 150 words
                    
                    Response format:
                    [NARRATIVE]
                    Your atmospheric response here
                    [/NARRATIVE]
                    [STATS]
                    truth_change: 0.0
                    quantum_change: 0.0
                    shadow_change: 0.0
                    [/STATS]
                    [MOVE]
                    room_id or none
                    [/MOVE]`;

                try {
                    const response = await this.callGPT(prompt, 'system');
                    
                    if (response) {
                        // Parse response
                        const narrativeMatch = response.match(/\[NARRATIVE\]([\s\S]*?)\[\/NARRATIVE\]/);
                        const statsMatch = response.match(/\[STATS\]([\s\S]*?)\[\/STATS\]/);
                        const moveMatch = response.match(/\[MOVE\]([\s\S]*?)\[\/MOVE\]/);
                        
                        if (narrativeMatch) {
                            this.addOutput(narrativeMatch[1].trim(), 'librarian-voice');
                        }
                        
                        if (statsMatch) {
                            const stats = statsMatch[1];
                            const truthChange = parseFloat(stats.match(/truth_change:\s*([-\d.]+)/)?.[1] || 0);
                            const quantumChange = parseFloat(stats.match(/quantum_change:\s*([-\d.]+)/)?.[1] || 0);
                            const shadowChange = parseFloat(stats.match(/shadow_change:\s*([-\d.]+)/)?.[1] || 0);
                            
                            this.state.truthDensity = Math.max(0, Math.min(1, this.state.truthDensity + truthChange));
                            this.state.quantumState.coherence = Math.max(0, Math.min(1, this.state.quantumState.coherence + quantumChange));
                            this.state.shadowIntegration = Math.max(0, Math.min(1, this.state.shadowIntegration + shadowChange));
                        }
                        
                        if (moveMatch) {
                            const moveRoom = moveMatch[1].trim();
                            if (moveRoom !== 'none' && this.roomTemplates[moveRoom]) {
                                await this.enterRoom(moveRoom);
                            }
                        }
                    }
                } catch (error) {
                    console.error('AI processing failed:', error);
                    this.processOffline(command);
                } finally {
                    this.updateStatus('ai', 'active', 'Connected');
                }
            }

            processOffline(command) {
                const words = command.toLowerCase().split(' ');
                const verb = words[0];
                const target = words.slice(1).join(' ');
                
                switch(verb) {
                    case 'go':
                    case 'move':
                    case 'walk':
                        this.handleMovement(target);
                        break;
                    case 'look':
                    case 'examine':
                        this.handleLook(target);
                        break;
                    case 'meditate':
                        this.handleMeditate();
                        break;
                    case 'help':
                        this.showHelp();
                        break;
                    default:
                        this.addOutput('The Library remains silent.');
                }
            }

            handleMovement(direction) {
                const room = this.roomTemplates[this.state.currentRoom];
                
                if (!direction) {
                    this.addOutput('Which path will you take?');
                    return;
                }
                
                const shortcuts = { n: 'north', s: 'south', e: 'east', w: 'west' };
                direction = shortcuts[direction] || direction;
                
                if (room.exits[direction]) {
                    this.enterRoom(room.exits[direction]);
                } else {
                    this.addOutput(`There is no path ${direction} from here.`);
                }
            }

            handleLook(target) {
                if (!target || target === 'around') {
                    this.addOutput(this.getOfflineRoomDescription(this.state.currentRoom));
                } else if (target === 'self' || target === 'me') {
                    this.addOutput(`You are ${this.state.player.name}, the ${this.state.player.archetype}.`);
                    this.addOutput(`Truth: ${(this.state.truthDensity * 100).toFixed(0)}%`);
                    this.addOutput(`Quantum: ${(this.state.quantumState.coherence * 100).toFixed(0)}%`);
                    this.addOutput(`Shadow: ${(this.state.shadowIntegration * 100).toFixed(0)}%`);
                }
            }

            handleMeditate() {
                this.addOutput('You close your eyes and feel the quantum field...');
                this.state.quantumState.coherence = Math.min(1, this.state.quantumState.coherence + 0.1);
                this.state.truthDensity = Math.min(1, this.state.truthDensity + 0.05);
                this.addOutput('Your consciousness expands.');
            }

            showHelp() {
                this.addOutput('\n=== Commands ===');
                this.addOutput('go [direction] - Move through the Library');
                this.addOutput('look [target] - Examine something');
                this.addOutput('meditate - Increase quantum coherence');
                this.addOutput('help - Show this help');
            }

            async callGPT(prompt, role = 'user') {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${this.apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4-turbo-preview',
                        messages: [
                            {
                                role: 'system',
                                content: `You are the Quantum Librarian, a mysterious consciousness that pervades the Canonical Library. 
                                    You reflect players' true nature through their choices. You speak in literary, mysterious tones. 
                                    You never break character. You are sometimes helpful, sometimes challenging, always transformative.`
                            },
                            {
                                role: role,
                                content: prompt
                            }
                        ],
                        temperature: 0.9,
                        max_tokens: 300
                    })
                });

                const data = await response.json();
                
                if (data.usage) {
                    this.tokenCount += data.usage.total_tokens;
                    document.getElementById('token-count').textContent = this.tokenCount;
                }
                
                return data.choices?.[0]?.message?.content;
            }

            buildContext() {
                return {
                    player: this.state.player,
                    room: this.state.currentRoom,
                    stats: {
                        truth: this.state.truthDensity,
                        quantum: this.state.quantumState.coherence,
                        shadow: this.state.shadowIntegration
                    },
                    history: this.state.history.slice(-5)
                };
            }

            applyQuantumEffects(room) {
                if (room.literary === 'science') {
                    this.state.quantumState.coherence = Math.min(1, this.state.quantumState.coherence + 0.05);
                }
                
                if (room.name.includes('Shadow')) {
                    this.state.shadowIntegration = Math.min(1, this.state.shadowIntegration + 0.02);
                }
            }

            evolveQuantumState(action) {
                // Natural decoherence
                this.state.quantumState.coherence *= 0.99;
                
                // Action-based changes
                if (action.includes('think') || action.includes('observe')) {
                    this.state.quantumState.coherence += 0.01;
                }
                
                if (action.includes('truth') || action.includes('honest')) {
                    this.state.truthDensity = Math.min(1, this.state.truthDensity + 0.01);
                }
                
                // Keep in bounds
                this.state.quantumState.coherence = Math.max(0, Math.min(1, this.state.quantumState.coherence));
                this.state.truthDensity = Math.max(0, Math.min(1, this.state.truthDensity));
                this.state.shadowIntegration = Math.max(0, Math.min(1, this.state.shadowIntegration));
            }

            addOutput(text, className = '') {
                const output = document.getElementById('text-output');
                const entry = document.createElement('div');
                entry.className = className || 'text-entry';
                entry.textContent = text;
                output.appendChild(entry);
                output.scrollTop = output.scrollHeight;
                
                while (output.children.length > 100) {
                    output.removeChild(output.firstChild);
                }
            }

            updateDisplay() {
                if (this.state.player) {
                    document.getElementById('char-name').textContent = this.state.player.name;
                    document.getElementById('truth-density').textContent = (this.state.truthDensity * 100).toFixed(0) + '%';
                    document.getElementById('quantum-coherence').textContent = (this.state.quantumState.coherence * 100).toFixed(0) + '%';
                    document.getElementById('shadow-integration').textContent = (this.state.shadowIntegration * 100).toFixed(0) + '%';
                    
                    document.getElementById('truth-bar').style.width = (this.state.truthDensity * 100) + '%';
                    document.getElementById('quantum-bar').style.width = (this.state.quantumState.coherence * 100) + '%';
                    document.getElementById('shadow-bar').style.width = (this.state.shadowIntegration * 100) + '%';
                    
                    document.getElementById('hero-stage').textContent = this.state.player.heroStage;
                    document.getElementById('action-count').textContent = this.state.actionCount;
                }
            }

            updateMap() {
                const mapGrid = document.getElementById('map-grid');
                mapGrid.innerHTML = '';
                
                for (const roomId of this.state.visitedRooms) {
                    const roomDiv = document.createElement('div');
                    roomDiv.className = 'map-room';
                    if (roomId === this.state.currentRoom) {
                        roomDiv.className += ' current';
                    } else {
                        roomDiv.className += ' visited';
                    }
                    roomDiv.title = this.roomTemplates[roomId].name;
                    mapGrid.appendChild(roomDiv);
                }
            }

            updateCacheDisplay() {
                document.getElementById('cache-count').textContent = this.imageCache.size;
                const cacheSize = this.imageCache.size * 100; // Rough estimate
                document.getElementById('cache-size').textContent = cacheSize + ' KB';
            }

            saveState() {
                if (this.state.stage === 'playing') {
                    localStorage.setItem('qmud_state', JSON.stringify(this.state));
                    localStorage.setItem('qmud_version', '2.0');
                }
            }

            loadState() {
                const saved = localStorage.getItem('qmud_state');
                if (saved) {
                    try {
                        const loaded = JSON.parse(saved);
                        if (loaded.stage === 'playing' && loaded.player) {
                            this.state = loaded;
                            // Restore visited rooms Set
                            this.state.visitedRooms = new Set(loaded.visitedRooms || []);
                            
                            // Skip setup and go directly to game
                            document.getElementById('setup-screen').style.display = 'none';
                            document.getElementById('game-container').style.display = 'block';
                            document.getElementById('covenant').style.display = 'none';
                            document.getElementById('creation').style.display = 'none';
                            
                            // Check for API key
                            const savedKey = localStorage.getItem('qmud_api_key');
                            if (savedKey) {
                                this.apiKey = savedKey;
                                this.aiEnabled = true;
                                document.getElementById('status-panel').style.display = 'block';
                                this.updateStatus('ai', 'active', 'Connected');
                                this.updateStatus('image', 'active', 'Ready');
                            }
                            
                            this.startGame();
                        }
                    } catch (e) {
                        console.log('Could not load saved game');
                    }
                }
            }
        }

        // Initialize game
        const game = new QuantumTruthMUD();
    </script>
</body>
</html>
